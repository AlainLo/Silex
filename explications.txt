-------------------------------------
SILEX 
-------------------------------------
SOMMAIRE :
INTRO : Qu'est ce que Silex ?
ÉTAPE 0 : Base de notre app : site_mvc (procédural)
ÉTAPE 1 : Installation de Silex
ÉTAPE 2 : Démarrage et compréhension
ÉTAPE 3 : Le routing avec Silex
ÉTAPE 4 : Virtual Host
ÉTAPE 5 : HTACCESS : on retire 'index.php' 
ÉTAPE 6 : Démarrage de notre application BOUTIQUE
ÉTAPE 7 : Utilisation de services Silex (Doctrine DBAL)
ÉTAPE 8 : Utilisation des services Silex (Twig)
ÉTAPE 9 : Utilisation des services Silex (Bootstrap)
ÉTAPE 10 : Ajout des commentaires à nos produits (Injection de dépendance)
ÉTAPE 11 : La classe DAO (Design pattern : comment transformer un tableau multi-dimensionnel 
	   composé d'arrays, en un tableau multidimensionnel composé d'objets)
ÉTAPE 12 : Héritage TWIG
ÉTAPE 13 : Gestion de la sécurité (Connexion)
ÉTAPE 14 : Class MembreDAO et UserProviderInterface
ÉTAPE 15 : Formulaire de Connexion
ÉTAPE 16 : Formulaire d'Inscription
ÉTAPE 17 : Formulaire de Contact
ÉTAPE 18 : BACKOFFICE
ÉTAPE 19 : Réorganisation en Controller
ÉTAPE 20 : Préparation de la mise en prod

--------------------------------
INTRO : Qu'est-ce que Silex ?
--------------------------------

1/ Avantages à utiliser un Framework ?
	A/ Choix d'une organisation optimisée. Il est trés difficile de conceptualiser soi-même
	une application en objet (un framework). Où vont les Controller ? Les Models ? Les vues ?
	Aucune réponse n'est parfaite,2 mais chacun a sa propre organisation cohérente ... ou pas.
	
	B/ Fonctionnalités communes : un Framework permet de récupérer des briques déjà existantes...
	et de les récupérer du site A vers le site B etc... (Briques : Connexion, Inscription, 
	Session, Commentaires, ...)

	C/ Services disponibles : tous les frameworks proposent des services : le routage (routing), 
	la sécurité, la gestion du cache. Cela vous permet de vous concentrer et de passer plus de 
	temps au développement de vos propres fonctionnalités !

2/ Quels choix de Frameworks ?
	A/  Son propre Framework maison ? 
	Trés formateur !! On peut toujours l'améliorer et l'utiliser dans des projets persos... 
	Par contre : pas de communauté, pas de documentation et c'est difficile de garantir tous 
	les aspects de sécurité.

	B / Frameworks du marché : 
		- Frameworks FullStack : (Symfony, Zend, Cake) : beaucoup de ervices disponibles, 
		grosse communauté, mais un déploiement très lourd et une architecture IMPOSÉE.
		
		- Mini-framework : (Laravel et Silex) : proposent des services à la carte et une 
		architecture plus souple.

3/ Et Silex dans tout ça ?
	A/ Silex est un framework développé par les équipes Sensio Labs qui sont les créateurs de Symfony.
	Il repose sur les mêmes composants.
	
	B/ On dit que Silex est un miniframework parfait pour l'apprentissage et la compréhension de
	 la logique framework. Parfait également pour développer des applications rapidement et première 
	étape intéressante dans l'apprentissage de Symfony

	C/ Documentation : https://silex.sensiolabs.org/doc/2.0
	
----------------------------------------------------
ETAPE O : Base de notre app : site mvc (procédural)
----------------------------------------------------
Pour commencer la compréhension de Silex, nous allons partir sur la base morceau de ste en procédural et en MVC afin d'avancer étape par étape :
slex/site/mvc
 -> css/ (copier de votre ancien site procédural)
-> photo/ (copier de votre ancien site procédural)
-> index.php (vide)
-> model.php (vide)
-> view.php (vide)

---------------------------------
ETAPE 1 : installation de Silex
---------------------------------
Sommaire :
1/ installation de Composer
2/ Création du dossier BOUTIQUE
3/ Commande pour télécharger les composants de Silex
3bis/ Autre technique pour télécharger les composants de silex
4/ tour d'horizon des composants

1/ Installation de Composer
Composer est un outil de gestion des dépendances. il permet d'installer des services
(composant, dépendances) est est rrelié à un fichier composer.json.

-> Télécharger Composer
-> Installer Composer (en précisant php.exe)

2/ création du dossier silex/BOUTIQUE/

3/ Commande pour télécharger les composants de Silex :
-> on se place dans le dossier BOUTIQUE/
-> Maj + clicDroit > " Ouvrir la fenêtre de commande ici"

	<cmd> composer require silex/silex "~2.0"

3.bis / composer.json
	<code>
	{
	    "require": {
	        "silex/silex": "~2.0"
	    }
	}

	<cmd> composer update

4/ les composants : 
Le dossier Vendor correspond au coeur de notre Framework. Il contient tous les composants récupérés de Silex/Symfony, sur lesquels nous n'interviendrons JAMAIS !!!

------------------------------------
ETAPE 2 : Démarrage et Compréhension
------------------------------------
Sommaire :
1/création du répertoire web/
2/Création du fichier index.php

1/ répertoire web/
A la racine de notre application BOUTIQUE/web.
Ce dossier constitue notre répertoire web. Cela signifie qu'il va contenir tout ce qui est visible et accessible pour l'interneaute (index.php, photos, img, fonts, js, css...)

2/ créer web/index.php
-> D'abord on require l'autoload qui ne chargera de require tous les fichiers dont on aura besoin. PRATIQUE !!

-> On instancie la classe Application : l'objet $app va représenter notre application et nous donnne accès à toutes les fonctionnalités de Silex.

-> Méthode run(): Lancement de l'application.

------------------------------
ÉTAPE 3 : Le routing sur Silex
------------------------------

Sommaire :
1/ Route Hello World
2/ Route Hello ($name)
3/ La fonction Get de notre application
4/ Arguments
5/ Fonction escape()

1/ Route Hello World
	-> $app -> get() est la fonction qui nous permet de créer une nouvelle route. Chaque route est une action dans notre application. Ensuite, nous rangerons toutes nos actions dans des controllers, pour optimiser notre organisation.

2/ Route Hello ($name)
-> Création de la route /hello/{name}
-> Test : local/host/Silex/BOUTIQUE/web/index.php/hello/Yakine

3/ La fonction Get
A chaque nouvelle fonctionnalité, on va utiliser le fonction get de $app, qui nous crée une nouvelle route. En plus de get, il existe post() et match(). Nous les verrons plus tard.

4/ Arguments :
-> le premier argument est le nom de la route. Les paramètres contenus dans les URL sont alors déclarés entre {}
-> le second argument function() est ce que l'on appelle une "closure" ou "fonction anonyme". Elle signifie que ce qui va suivre sera exécuté. Une fonction dans une fonction, finalement. Elle peut recevoir les paramètres dynamiques de notre URL. (ex: function($name)).

5/ La méthode escape()
-> la fonction escape() permet simplement d'afficher le paramètre contenu dans la route. La méthode escape() permet d'éviter les injections SQL dans votre URL.

----------------------
ÉTAPE 4 : Virtual Host
----------------------
Sommaire :
1/ Modifier le fichier vhost (apache)
2/ Modifier le fichier conf (apache)
3/ Modifier le fichier Host (system 32)

1/ Modifier le fichier vhost : 
< c:\xampp\apache\conf\extra\httpd-vhosts.conf

2/ Modifier le fichier conf :
< c:\xampp\apache\conf\httpd.conf

3/ Modifier le fichier Host (system 32)
< c:\windows\system32\drivers\etc\hosts


------------------------------------------
ÉTAPE 5 : HTACCESS POUR RETIRER INDEX.PHP :
------------------------------------------

-> Créer dans le dossier web de notre application, test.txt 

    <code>
    <IfModule mod_rewrite.c>
        Options -MultiViews
        
        RewriteEngine On
        RewriteCond %{REQUEST_FILENAME} !-f
        RewriteRule ^ index.php [QSA,L]
    </IfModule>

    -> Enregistrer le fichier avec l'extension .htaccess. Pour ce faire, selectionner tous les formats
    
    
Test à effectuer : www.boutique.dev/hello/yakine (modifié)


------------------------------------
ÉTAPE 6 : DÉMARRAGE DE l'APPLICATION
------------------------------------
Sommaire : 
1/ Création des dossiers
2/ Récupérer les fichiers (de notre base site_mvc)
3/ Création du fichier de routes
4/ Ré-écriture de index.php
--------------------------------------

1/ Création des dossiers :
    BOUTIQUE/    
        web/      (déjà créé)
        vendor/ (déjà créé)
        app/     (config de l'application)
        db/     (script de creation de la bdd)
        src/     (fichiers sources de notre application)
        views/     (les vues de notre application)

2/ Récupérer les fichiers (denotre base site_mvc)
Dans un premier temps, on va gérer l'affichage de nos produits (boutique.php)
-> model.php à copier/coller dans src/
-> view.php à copier/coller dans views/
-> css/ et photo/ à copier/coller dans web/

3/ Créer un fichier de routes (qui va contenir toutes nos routes)
-> app/routes.php
-> On re-crée la route '/' (la home), dans laquelle on va récupérer les infos de tous nos produits (grâce à model.php et sa fonction afficheAll()) et on les affiche via la concept render() (temporisation puis affichage)

4/ ré-écriture de index.php
-> À ce stade, nous n'avons plus besoin des 2 routes écrites dans index.php, mais a besoin de require notre fichier de routes (routes.php)
-> On ajoute le mode debug, car nous sommes en dev.

Test: www.boutique.dev

À ce stade, nous devrions avoir la boutique qui s'affiche sur la home de notre site ; En revanche, nous sommes en procédural, il va donc falloir ajouter une couche objet.

-----------------------------------------
ÉTAPE 7 : UTILISATION DES SERVICES SILEX : 
DOCTRINE DBAL + modélisation objet
-----------------------------------------
Sommaire :
1/ Création de la classe Produit dans src/Entity
2/ Remplacement de PDO par Doctrine DBAL
3/ Créer le dossier DAO (Data Access Object)
4/ Ajouter le fichier ProduitDAO.php
5/ Mise à Jour de l'application via Composer
6/ Création du fichier app.php dans app/
7/ Création du fichier prod.php dans app/config/
8/ Création du fichier dev.php dans app/config/
9/ Modification des Routes
10/ Modification de la vue
11/ Modification de l'index.php
-------------------------------

1/ Création de la classe Produit dans src/Entity
-> Création de la classe Produit dans src/Entity/Produit.php
-> Cette classe va servir de plan de fabrication d'un objet produit, un prototype. Il contient toutes les propriétés de l'entité produit(private) et tous les getters/setters. On dit que cette classe est une POPO (Plain Old PHP Object).

2/ Remplacement de PDO par Doctrine DBAL
	-> Doctrine DBAL (DataBase Abstract Layer) : fait la même chose que PDO mais améliore le système de requête. Ce service de Silex nous permet également une connexion compatible avec tout type de gestion de BDD. Il nous récupère la connexion dans un SINGLETON sans qu'on ait besoin de le faire nous-même.

3/ Création du dossier DAO (Data Access Object)	
	-> DAO : data Access Object : DAO est un design pattern qui répond à la question : Comment récupérer des infos depuis la base de Données non pas sous forme d'array, mais sous forme d'objets ? ==> voir la méthode (buildProduit())

4/ Création du fichier ProduitDAO.php dans src/DAO/
	-> ce fichier correspond à notre MODEL PRODUIT. C'est lui qui va gérer toutes les requêtes auprès de la table produit, et nous renvoyer les résultats sous forme d'objets.
	-> On a récupéré la connexion à la base de données grâce à Doctrine\DBAL\Connction
	-> on stocke cette connexion dans la propriété private $db.
	-> chaque requête sur la table produit sera représenté par une fonction (FindAll, FindAllById, findAllByCategorie, findAllCategorie etc... )
	-> Pour chacune de ces requêtes, quand cela est possible, on va transformer les résultats d'arrays en objets grâce à la méthode buildProduit().

	====>DAO est un design pattern qui permet de modéliser sous forme d'objet (Entity) les résultats d'une requête.

5/ Mise à Jour de notre application via Composer
-> Modifier notre fichier composer.json

<code>
	  {
        "require": {
            "silex/silex": "~2.0",
            "doctrine/dbal": "2.5"
        },
        "autoload": {
            "psr-4" : {"BOUTIQUE\\": "src"}
        }
    }

    <cmd>
    composer update

    -> Cette commande a  : 
    	- récupéré les composants Doctrine DBAL ;
    	- mis à jour l'autoload selon la norme PSR-4 (les noms des namespace correspondent à des noms de dossier);

6/ Création du fichier app.php dans le dossier app/
	-> ce fichier représente les paramètres de notre application. Quand vous déplacerez votre application d'un serveur à un autre, en théorie vous ne devrez modifier que ce fichier-là...  ...À l'instar de init.inc.php dans notre procédural.

	-> Les deux premières lignes (use ErrorHandler et ExceptionHandler) permettent à notre application de gérer des erreurs sous forme d'exception. Les composants Symfony prennent la main sur la gestion des erreurs PHP.

	-> Ensuite, on enregistre le fournisseur de services associé à Doctrine DBAL. À faire pour tous les services utilisés.

	-> Enfin, on déclare/enregistre notre class ProduitDAO dans notre $app['dao.produit']. Cela nous permettra de rendre plus simple l'utilisation de notre instance de la classe produitDAO. $app['db'] représente par ailleurs notre connexion à la BDD grâce à Doctrine DBAL.

7/ création du fichier prod.php dans app/config/
	-> ce fichier contient toutes les infos de connexion à la base de données. 

8/ Création du fichier dev.php dans app/config/
	-> ce fichier contient les infos relatives à la phase de dev.

9/ Modification du fichier Routes.php
-> On remplace l'ancien require model.php qui nous permettait d'accèder à la méthode afficheAll() par une instanciation de ProduitDAO ($app['produitDAO']) qui est notre nouveau model. Dans ce nouveau model, one exécvute findAll() et findAllCategorie. 
===> la logique Controller / Model reste la même qu'auparavant.

	// $app -> get('/', function(){
		//require '../src/model.php';

		//$infos = afficheAll();

		//$produits = $infos['produits'];
		//$categories = $infos['categories'];

		//ob_start(); 
		//require '../views/view.php';
		//$view = ob_get_clean(); 
		//return $view;

	// créer en étape 7.9 :

	$app -> get('/', function(){

	$produits = $app['dao.produit'] -> findAll();
	// $produits = objetModelProduit (ProduitDAO) -> findAll();
	// produits est un tableau multidimensionnel composé d'objets

	ob_start();
	require '../views/view.php' ;
	$view = ob_get_clean();
	return $view; 

});

/!\ ATTENTION : dans notre vue view.php, nous utilisions des arrays ($produit['titre']) mais maintenant on doit utiliser des objets ($produit -> getTitre())

10/ Modification de view.php
	-> On remplace les arrays par l'utilisation des getter :
	ARRAY : <?= $pdt['titre'] ?>
	OBJET : <?= $pdt -> getTitre() ?>
	TWIG : {( pdt.titre)}



11/ modification du fichier index.php
	-> on met en commentaire $app['debug'] = true;, puisque nous l'avons mis dans dev.php
	-> On ajoute les require de app.php et dev.php avant le require de routes.php

===> à ce stade, notre home doit afficher tous les produits et le menu des catégories. Cette étape nous a permis d'introduire une modélisation objet (propore à Silex : DAO, Routing...).
===> Nous avons beraucoup travaillé la partie MODELS (DAO) et CONTROLLER (routes.php), à l'étape suivante, nous allons nous intéresser à la partie VIEWS avec TWIG


-------------------------------------------------
ÉTAPE 8 : UTILISATION DES SERVICES SILEX (Twig) :
(Ajout de l'utilisation de la fonction render)
-------------------------------------------------
Sommaire :
1/ Intro
2/ Modification composer.Json
3/ Mise à jour via Composer
4/ Modification de app.php (enregistrement des nouveaux services)
5/ Modification des fichiers view.php, produit.php en Twig
6/ Fonction render() : modification des routes
---------

1/ Intro
 -> Il existe plusieurs moteurs de template : Liquid, TPL, Smarty, Blade, Twig.
 Pour Symfony et Silex, le moteur c'est TWIG.
 -> De manière générale, un moteur de template permet de simplifier l'insertion de variables et de boucles PHP dans des blocs HTML (idée des formes contractées).
 -> TWIG a l'avantage de proposer un système d'héritage. En d'autres termes, des morceaux d'HTML vont hériter d'autres morceaux d'HTML. Exemple : le formulaire d'inscription hérite du template général de la page.

2/ Modification  du JSON : 
	<code>
	{
        "require": {
            "silex/silex": "~2.0",
            "doctrine/dbal": "2.5",
            "twig/twig": "~1.28"
        },
        "autoload": {
            "psr-4" : {"BOUTIQUE\\": "src"}
        }
    }

 3/ Mise à jour via composer
  <cmd>
    composer update (dans le power shell)

 4/ Modification de app.php
 		-> enregistrement aux services Twig
 		-> L'enregistrement nécessite qu'on passe en argument le chemib de nos vues

 		<code>
 		$app ->register(new Silex\Provider\TwigServiceProvider(),
 		array(
 		'twig.path' -> __DIR__ . '/../views'
 		));

 5/ Modifications de nos vues :
 		-> view.php ==> index.html.twig
 		-> produit.php ===> produit.html.twig

 		<php>
 		<?php foreach($produits as $pdt) : ?>
 		$pdt -> getTitre()
 		<?php endforeach; ?>

 		<twig>
 		{# commentaire en twig #}
 		{% for pdt in produits %}
 			{{pdt.titre}}
 		{% endfor %}

 	6/ Modification des routes
 	-> ajout de la méthode render()

 -> la méthode render est globalement commune à toutes les applications OBJET/MVC bien mododélisées. Elle va rendre une vue et embarquer tous les paramètres dynamiques nécessaires à cette vue.
 -> Les paramètres embarqués le sont toujours sous forme d'un array.

===> à ce stade , notre home doit s'afficher. Test : www.boutique.dev.
 ===> en savoir plus sur Twig : https://twig.symfony.com/

---------------------------------------------------
ÉTAPE 9 : UTILISATION DES SERVICES SILEX (Assets) :
---------------------------------------------------
Sommaire :
1/ Modification de composer.json
2/ mise à jours des services
3/ Modifications de app.php
4/ modification des vues (chemins css/js/image)
5/ modification des vues (liens)

1/ Modification de Composer.JSON

<code>
{
        "require": {
            "silex/silex": "~2.0",
            "doctrine/dbal": "2.5",
            "twig/twig": "~1.28",
            "symfony/asset": "~2.8|3.0.*"
        },
        "autoload": {
            "psr-4" : {"BOUTIQUE\\": "src"}
        }
    }    
2/  <cmd>
    composer update
    composer require symfony/twig-bridge

 3/ Modification du fichier app.php
   <code>
	   $app -> register(new Silex\Provider\AssetServiceProvider(), array(
	        'assets.version' => 'v1'
	    ));

  4/ Modification des chemins css/js/photo
  -> On modifie tous les chemins des ressources de cette manière : 
		  src="/photo{{ pdt.photo }}"
		  href="../css/style.css"
		  href="../bootstrap/js/bootstrap.min.js"

		  src="{{ asset('photo/' ~ pdt.photo ) }}"
		  href="{{ asset('/css/style.css' ) }}"
		  href="{{ asset('bootstrap/js/bootstrap.min.js') }}"

   5/ modifications des vues et des routes 
	-> Liens : 
		- href="/profil/"
		- href="/boutique/{{ catagorie.categorie }}" 
		-href="/produit/{{ pdt.id_produit }}"

		- href="{{ path('profil') }}"
		- href="{{ path('boutique', {'categorie' :categorie.categorie} ) }}"
		- href="{{ path ('produit', {'id' : pdt.iod_produit} ) }}"

	- chaque route va avoir un nom :
			$app -> get('/profil/', function() use($app){
				// traitement...
				// traitement...
			}) -> bind'('profil');

			$app->get('/boutique/{categorie}'
			)->bind('boutique'); 

			$app->get('/produit/{id}'
			)-> bind('produit');

	-> Grâce au service assets de Silex, tous nos liens et chemeins vont être dynamisés et  absolus
	-> Pour cela, on utilise asset() (ressources) et path() (lien). Concernant path(), Pour que cela fonctionne, il faut que toutes nos routes aient un nom.

-------------------------
ÉTAPE 12 : HÉRITAGE TWIG
-------------------------

Sommaire :
1/ Créer le fichier layout.html.twig (structure de page) dans views/
2 Modifier nos vues :

1/ création du fichier layout.html.twig
		-> on y met toute la structure d'une page
		<!DOCTYPE html>
		...
		<section>
		...

		{% block content %}{% endblock %}
		...
		</section>
		</html>
2/Modifier les vues :
	<code>
	{% extends 'layout.html.twig %}
	{% block content %}

		****** contenu de la page ******

	{% endblock %}

--------------------------------
ÉTAPE 17 : FORMULAIRE DE CONTACT
--------------------------------
Sommaire :
1/ Créer la route
2/ Faire le fichier contact.html.twig
3/ Créer ContactType (la classe qui va nous construire les formulaires)
	-> mise à jour de l'app (JSON + composer)
	<code>
	{
	"require" {
	"silex/silex": "~2.0",
	"doctrine/dbal": "2.5",
	"twig/twig": "~1.28",
	"symfony/asset": "~2.8|3.0.*",
	"symfony/twig-bridge": "^"
	}
	}
	-> enregistrement service form
	-> Form/Type/ContactType
4/ Modifier la route (récupération du formulaire)
5/ Modifier la vue contact.html.twig
6/ Modifier la route (traitement de l'email)

